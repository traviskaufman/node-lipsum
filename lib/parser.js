// Generated by CoffeeScript 1.12.7

/*
   * Lipsum Parser

  Detects whether input is XML or JSON and parses accordingly.
  Parsing within the file provides the advantage of decoupling server calls with
  calls to the parser, as it is able to be agnostic to the format received. It
  cannot, however, parse HTML (nor should it have to).
 */
var LipsumParser, XMLParser, events,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

XMLParser = require('xml2js').Parser;

events = require('events');

LipsumParser = (function(superClass) {
  extend(LipsumParser, superClass);

  function LipsumParser(payload) {
    this._error = bind(this._error, this);
    this._success = bind(this._success, this);
    this._attemptParseXML = bind(this._attemptParseXML, this);
    this._attemptParseJSON = bind(this._attemptParseJSON, this);
    this.parse = bind(this.parse, this);
    this.feed = bind(this.feed, this);

    /* Instantiates the class with an optional payload */
    this._xmlParser = new XMLParser();
    this._payload = payload != null ? payload : null;
    this.parsedOutput = null;
  }

  LipsumParser.prototype.feed = function(payload) {

    /*
    Given a payload (which should be XML or JSON), it stores
    this and then returns itself for chainability.
     */
    this.parsedOutput = null;
    this._payload = payload;
    return this;
  };

  LipsumParser.prototype.parse = function(successCallback, errCallback) {

    /*
    Parses the payload it was Given
    
    successCallback: {Function} called on successful parse.
                     Takes one parameter that contains the parsed
                     output.
    
    errCallback: {Function} called on parsing error from XML parser.
                 Note that this will be called even if the payload is JSON,
                 since JSON is attempted to be parsed first.
     */
    var errMsg, xmlErrCallback, xmlParseErrors, xmlSuccCallback;
    successCallback = successCallback || function() {
      return {};
    };
    errCallback = errCallback || function() {
      return {};
    };
    if (this._payload == null) {
      throw new ReferenceError("Nothing to parse.");
    }
    if (this.parsedOutput != null) {
      this._success(successCallback, this.parsedOutput);
      return;
    }
    this.parsedOutput = this._attemptParseJSON();
    xmlParseErrors = null;
    if (this.parsedOutput == null) {
      xmlSuccCallback = (function(_this) {
        return function(result) {
          return _this.parsedOutput = result;
        };
      })(this);
      xmlErrCallback = function(err) {
        return xmlParseErrors = err;
      };
      this._attemptParseXML(xmlSuccCallback, xmlErrCallback);
    }
    if (this.parsedOutput != null) {
      this._success(successCallback, this.parsedOutput);
    } else {
      if (xmlParseErrors != null) {
        this._error(errCallback, xmlParseErrors);
      } else {
        errMsg = "Could not parse " + this._payload;
        this._error(errCallback, errMsg);
      }
    }
    return this;
  };

  LipsumParser.prototype._attemptParseJSON = function() {
    var SyntaxError;
    try {
      return JSON.parse(this._payload);
    } catch (error) {
      SyntaxError = error;
    }
  };

  LipsumParser.prototype._attemptParseXML = function(onSuccess, onError) {
    return this._xmlParser.parseString(this._payload, function(err, result) {
      if (err) {
        if (onError != null) {
          onError(err);
        }
      }
      return onSuccess(result);
    });
  };

  LipsumParser.prototype._success = function(succCallback, data) {
    succCallback(data);
    return this.emit('success', data);
  };

  LipsumParser.prototype._error = function(errCallback, data) {
    errCallback(data);
    return this.emit('error', data);
  };

  return LipsumParser;

})(events.EventEmitter);

if (typeof module !== "undefined" && module !== null) {
  module.exports = LipsumParser;
}
